<!DOCTYPE html>
<html>
<head><title>Container</title><meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="container.css">
</head>
<body onload="initDivAndLogger()">
<button type="button" onClick="initializationFetch(this)" style="margin-bottom: 5px;">Initialization</button>
<div class="table">
 <div class="tr">
  <span>Label</span><input id="s1" type="text" onchange="onInputValueChange(this.id)" value="Free text">
  <span>Category</span><div class="td" id="dvCateg" categSelID="sCateg"></div>
 </div>
 <div class="tr" >
  <label for="s11">Level</label><input id="s11" type="number" style="max-width: 4em" oninput="onInputValueChange(this.id)" value="2">	
  <label for="s12">Delta</label><input id="s12" type="number" style="max-width: 6em" oninput="onInputValueChange(this.id)">	
 </div>
 <div class="tr">
  <span>Event Date</span><input id="s4" type="date" onchange="onInputValueChange(this.id)" value="2021-05-21">
  <span>Date 2</span><input id="s5" type="date" onchange="onInputValueChange(this.id)">
 </div>
 <div class="tr">
  <span>Group.A</span><div class="td" id="s2"></div><span>Group.B</span><div class="td" id="s3"></div>
 </div>
</div>
<p><button id="btnExec" type="button" onClick="applyConstraints(0)" disabled>Apply Constraints</button></p>
<textarea id="msg" rows="8" cols="75"></textarea>
<script src="container.js"></script>
<script src="grid.js"></script>		<!-- required by trigger.js -->
<script src="trigger.js"></script>
<script>
var logger;
var flagWait = false;
var mJsonRaw = {};
var mExecutor = {};

var mLocalCtxt = {	// Keep existing structure (except actions), to be simplied later
	clientId: 0,
	state: { props: [], grids: []},
	constraints: []
};

var dfnCateg = {
	ND: "No Delta",
	FIX: "Fixed Delta",
	DR: "Delta Range"
};

function initLocalCtxt()
{
	let props = mLocalCtxt.state.props;
	
	function addLocalState(elts) {
		for (let index = 0; index < elts.length; ++index) {
			let inputElt = elts[index];
			let propId = parseInt(inputElt.id.substr(1));
			if (isNaN(propId)) {
				console.log('Unexpected Id: ' + nputElt.id);
			} else {
				props.push({prop_id:propId, val: inputElt.value});
			}
		}	
	}
	
	addLocalState( document.getElementsByTagName('input') );
	addLocalState( document.getElementsByTagName('select') );
}

function updateLocalCtxt(json)
{
	mLocalCtxt.clientId = json.client_id;
	for (let prop of json.state.props) {
		if (prop.hasOwnProperty('grid_id')) {
			let rec = {prop_id: prop.prop_id, grid_id: prop.grid_id};
			mLocalCtxt.state.grids.push(rec);
		}			
	}		
}

function gridAnchor(idClient, idGrid, stUpdate) {
	let url = '<a href="grid.html?cid=' + idClient + '&grd=' + idGrid;
	if (stUpdate)	{ url += '&st=U'; }
	url += '" target="_blank">GV.' + idGrid + '</a>';
	return url;
}

function onInputValueChange(id, val) {
	applyConstraints(id);
}

function initDivAndLogger()
{
	let mDivCateg = document.getElementById("dvCateg");
	
	function selectBox(vEltId) {
		let selectList = document.createElement("select");
		for (const [key, value] of Object.entries(dfnCateg)) {
			let option = document.createElement("option");
			option.value = key;
			option.text = value;
			selectList.appendChild(option);
		}	
		selectList.id = vEltId;
		return selectList;	
	}

	function addDropDown(prop) {
		const handler = () => {
			onInputValueChange(selectList.id, selectList.value);
		};
		let selectList = selectBox('s' + prop.prop_id);
		selectList.addEventListener("change", handler, false);
		mDivCateg.appendChild(selectList);
		selectList.value = prop.val;
	}
	
	addDropDown({prop_id: 10, val: 'ND'});	// s10 - categ
	initLocalCtxt();	
	
	// logger
	let txtMsg = document.getElementById("msg");	// TextArea	
	logger = (msg) => {txtMsg.value += msg + '\r\n'};
}

function initializationFetch(btn)
{
	const processJson = (json) => {
		mJsonRaw = json;
		mExecutor.constraints = json.constraints;
		mExecutor.actions = json.actions;
		updateLocalCtxt(json);

		for (let grid of mLocalCtxt.state.grids) {
			let elt = document.getElementById('s' + grid.prop_id);	// Prefix-S
			elt.innerHTML = gridAnchor(mLocalCtxt.clientId, grid.grid_id, false);
		}
	};

	document.getElementById("msg").value = '';	// TextArea	
	btn.disabled = true;
	fetch("/data/0").then(	// <---- Init
		(response) => response.json()
	).then((data) => {
		processJson(data);
		document.getElementById('btnExec').disabled  = false;
	}).catch((err) => {
		console.log(err);
		btn.disabled = false;
	});
}

function applyConstraints(id0)
{
	function updateProp(prop) {
		let elt = document.getElementById('s' + prop.prop_id);	// Prefix-S
		if (!elt) {
			logger('W! No html element for id: ' + prop.prop_id);
			return;
		}
		if (!prop.hasOwnProperty('val')) {
			elt.innerHTML = gridAnchor(mJsonRaw.client_id, prop.grid_id, true);;
		} else {
			elt.value = prop.val;
			if (prop.setby > 0) {
				elt.title = "Set by " + prop.setby;
				elt.className = "setby";
			}
		}
	}

	function uploadState(recState) {
		mJsonRaw.state = recState;	// ATTN
		let jdata = JSON.stringify(mJsonRaw);
		flagWait = true;
		fetch('/upload/state', {
			method: "POST",
			body: jdata,
			headers: {"Content-type": "application/json; charset=UTF-8"}
		}).then(response => response.json()
		).then(data => {
			flagWait = false;
			console.log(data);
		}).catch(err => {
			flagWait = false;
			console.log(err);
		});
	}
	
	document.getElementById("msg").value = '';	// TextArea	

	let newState = {state: mLocalCtxt.state, constraints: mLocalCtxt.constraints};	// TODO	
	let objState = createConstainer(newState);	// include container.js
	trigger(id0, objState, logger);		// include trigger.js	-- TODO param1 id

	newState.props.forEach(updateProp);
	
	if (window.location.protocol !== 'file:' && !flagWait) {		
		uploadState(newState);
	}
}
</script>
</body>
</html>
